;;;;;;;;;;;;;;;;;;;
;; Global Variables

global FILE_PATH
global ROOT_NODE
global JUMP_TO_SCOPE_NODE

;;;;;;;;;;;;;;;;;;;;;;;
;; Attribute Shorthands

attribute node_definition = node        => type = "pop_symbol", node_symbol = node, is_definition
attribute node_reference = node         => type = "push_symbol", node_symbol = node, is_reference
attribute pop_node = node               => type = "pop_symbol", node_symbol = node
attribute pop_scoped_node = node        => type = "pop_scoped_symbol", node_symbol = node
attribute pop_scoped_symbol = symbol    => type = "pop_scoped_symbol", symbol = symbol
attribute pop_symbol = symbol           => type = "pop_symbol", symbol = symbol
attribute push_node = node              => type = "push_symbol", node_symbol = node
attribute push_scoped_node = node       => type = "push_scoped_symbol", node_symbol = node
attribute push_scoped_symbol = symbol   => type = "push_scoped_symbol", symbol = symbol
attribute push_symbol = symbol          => type = "push_symbol", symbol = symbol
attribute scoped_node_definition = node => type = "pop_scoped_symbol", node_symbol = node, is_definition
attribute scoped_node_reference = node  => type = "push_scoped_symbol", node_symbol = node, is_reference
attribute symbol_definition = symbol    => type = "pop_symbol", symbol = symbol, is_definition
attribute symbol_reference = symbol     => type = "push_symbol", symbol = symbol, is_reference

attribute node_symbol = node            => symbol = (source-text node), source_node = node

; ######                                                   
; #     # #####   ####   ####  #####    ##   #    #  ####  
; #     # #    # #    # #    # #    #  #  #  ##  ## #      
; ######  #    # #    # #      #    # #    # # ## #  ####  
; #       #####  #    # #  ### #####  ###### #    #      # 
; #       #   #  #    # #    # #   #  #    # #    # #    # 
; #       #    #  ####   ####  #    # #    # #    #  ####  
;
; ########################################################

;; Attributes defined on programs
;
; out .lexical_scope
;     Lexical scope.
;
; in .defs
;     Lexical and variable definitions.
;
; in .exports
;     Exported definitions.
;
; out .mod_def
;     Module definition

(program)@prog {
  node @prog.defs
  node @prog.exports
  node @prog.lexical_scope
  node @prog.mod_def
  node @prog.mod_def__ns
}

(program)@prog {
  ; propagate lexical scope
  edge @prog.lexical_scope -> ROOT_NODE

  ; expose definitions
  edge @prog.lexical_scope -> @prog.defs

  ; module definition in ROOT_NODE scope
  edge ROOT_NODE -> @prog.mod_def__ns
  ;
  attr (@prog.mod_def__ns) pop_symbol = "%M"
  edge @prog.mod_def__ns -> @prog.mod_def
  ;
  let mod_name = (path-filestem FILE_PATH)
  let mod_path = (path-normalize (path-join (path-dir FILE_PATH) mod_name))
  attr (@prog.mod_def) symbol_definition = mod_path, source_node = @prog
  ; expose exports via module definition
  edge @prog.mod_def -> @prog.exports

  ; if this is an index.ts, also add a definition for the directory of this file
  scan mod_name {
    "index" {
      node mod_index_def
      edge @prog.mod_def__ns -> mod_index_def
      let mod_dir = (path-normalize (path-dir FILE_PATH))
      attr (mod_index_def) symbol_definition = mod_dir, source_node = @prog
      edge mod_index_def -> @prog.exports
    }
  }
}

(program
  (_)@stmt
)@prog {
  ; propagate lexical scope
  edge @stmt.lexical_scope -> @prog.lexical_scope

  ; expose lexical and variable declarations
  edge @prog.defs -> @stmt.lexical_defs
  edge @prog.defs -> @stmt.var_defs

  ; exports are visible via module definition
  edge @prog.exports -> @stmt.exports
}

;; Statements
[
  (class_declaration)
]@stmt {
  node @stmt.lexical_scope
  node @stmt.lexical_defs
}

;; Class Expressions

; class Bar extends Foo {
;   baz() {}
; }

; class Foo {
; }

(class_declaration
  name: (identifier) @name) @class
{
    node @class.def
    attr (@class.def) kind = "definition"
    attr (@class.def) symbol = @name
    edge @class.containing_scope -> @class.def
}
