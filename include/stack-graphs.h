#ifndef STACK_GRAPHS_H_
#define STACK_GRAPHS_H_

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

// Contains all of the nodes and edges that make up a stack graph.
struct sg_stack_graph;

// A name that we are trying to resolve using stack graphs.
//
// This typically represents a portion of an identifier as it appears in the source language.  It
// can also represent some other "operation" that can occur in source code, and which needs to be
// modeled in a stack graph — for instance, many languages will use a "fake" symbol named `.` to
// represent member access.
struct sg_symbol {
    const char *symbol;
    size_t symbol_len;
};

// An array of all of the symbols in a stack graph.  Symbol handles are indices into this array.
// There will never be a valid symbol at index 0; a handle with the value 0 represents a missing
// symbol.
struct sg_symbols {
    const struct sg_symbol *symbols;
    size_t count;
};

// A handle to a symbol in a stack graph.  A zero handle represents a missing symbol.
//
// We deduplicate symbols in a stack graph — that is, we ensure that there are never multiple
// `struct sg_symbol` instances with the same content.  That means that you can compare symbol
// handles using simple equality, without having to dereference them.
typedef uint32_t sg_symbol_handle;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Creates a new, initially empty stack graph.
struct sg_stack_graph *sg_stack_graph_new(void);

// Frees a stack graph, and all of its contents.
void sg_stack_graph_free(struct sg_stack_graph *graph);

// Returns a reference to the array of symbol data in this stack graph.  The resulting array
// pointer is only valid until the next call to any function that mutates the stack graph.
struct sg_symbols sg_stack_graph_symbols(const struct sg_stack_graph *graph);

// Adds new symbols to the stack graph.  You provide an array of symbol content, and an output
// array, which must have the same length.  We will place each symbol's handle in the output
// array.
//
// We ensure that there is only ever one copy of a particular symbol stored in the graph — we
// guarantee that identical symbols will have the same handles, meaning that you can compare the
// handles using simple integer equality.
//
// We copy the symbol data into the stack graph.  The symbol content you pass in does not need to
// outlive the call to this function.
//
// Each symbol must be a valid UTF-8 string.  If any symbol isn't valid UTF-8, it won't be added
// to the stack graph, and the corresponding entry in the output array will be the null handle.
void sg_stack_graph_add_symbols(struct sg_stack_graph *graph,
                                size_t count,
                                const char *const *symbols,
                                const size_t *lengths,
                                sg_symbol_handle *handles_out);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* STACK_GRAPHS_H_ */
